# 共享模型之管程

## 共享变量带来的问题

### Java 体现

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是否为 0？

```java
static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", counter);
    }
```

### 问题分析

以上结果可能是正数、负数、零。因为 Java 中对静态变量的自增，自减并不是原子操作，需从字节码来进行分析

例如对于 i++ 而言 (i 为静态变量)，实际会产生如下的 JVM 字节码指令：

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
iadd           // 自增
putstatic   i  // 将修改后的值存入静态变量i
```

而对应 i-- 也是类似

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
isub           // 自减
putstatic   i  // 将修改后的值存入静态变量i
```

而 Java 的内存模型下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![](../../pics/20210913213314.png)

在多线程的情况下会发生指令交错，出现正数、负数、零三种情况

### 临界区 Critical Section

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问共享资源
  - 多个线程读共享资源其实也没有问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
- 一段代码如果存在对共享资源的多线程读写操作，称这段代码为临界区

例如：

```java
static int counter = 0;

static void increment(){
    // 临界区
    counter ++;
}
static void decrement(){
    // 临界区
    counter --;
}
```

### 竞态条件

多个线程在临界区内执行，由于代码的**执行序列**不同而导致**结果无法预测**，称之为发生了竞态条件

## synchronized 解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的

- 阻塞式的解决方案：synchronized, Lock
- 非阻塞式的解决方案：原子变量

下面使用阻塞式的方案： synchronized 来解决上述问题，即俗称**对象锁*，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程再想要获取这个对象锁时就会阻塞。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换

**注意**

虽然 Java 中的互斥和同步都可以采用 synchronized 关键字来完成，但是它们是有区别的：

- 互斥是保证临界区的竞态条件发生时，同一时刻只能有一个线程执行临界区的代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点
  
### synchronized 

**语法**

```java
synchronized(对象){
    临界区
}
```
**理解**

假如线程1拿到对象锁，当其他线程尝试获取锁时就会阻塞（BLOCKED）,线程1执行完临界区的代码后释放锁同时唤醒其他线程去争取锁

**解决**

```java
 static int counter = 0;
    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
                for (int i = 0; i < 5000; i++) {
                    synchronized (lock){
                        counter++;
                }
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
                for (int i = 0; i < 5000; i++) {
                    synchronized (lock) {
                        counter--;
                }
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", counter);
    }
```

**思考**

synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换打断

- 如果把 synchronized(obj) 放在 for 循环外面，如何理解？
  
  ```java
  synchronized（lock){
      for (int i = 0; i < 5000; i++) {
          counter ++;
      }
  }
  ```
  synchronized 里的整个 for 循环是不可分割的，假如 t1 获得锁，会执行完 5000 次 counter ++ 操作后再释放锁。

- 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？
  
  无法保证对 counter 共享资源操作的原子性，两个线程同时执行临界区代码区获取锁时，获取的不是同一把对象锁，无法保证互斥

- 如果 t1 synchronized(obj) 而 t2 没有加会怎样？
  
  无法保证对 counter 共享资源操作的原子性，由于 t2 没有加锁，当 t1 没有释放锁（未执行完临界区代码）就发生时间片切换时，t2 执行临界区代码不会被阻塞

**总结**

synchronized 用锁保证了临界区代码的原子性，会给临界区的代码加一个锁，当一个线程要执行 synchronized 内的代码（临界区内的代码）时，先要尝试获取这个锁，如果这个锁已经被其他线程获得，那么当前线程就会阻塞（BLOCKED）,等会持有锁的线程释放锁后被唤醒，再去尝试获取锁
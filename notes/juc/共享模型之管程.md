# 共享模型之管程

## 共享变量带来的问题

### Java 体现

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是否为 0？

```java
static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", counter);
    }
```

### 问题分析

以上结果可能是正数、负数、零。因为 Java 中对静态变量的自增，自减并不是原子操作，需从字节码来进行分析

例如对于 i++ 而言 (i 为静态变量)，实际会产生如下的 JVM 字节码指令：

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
iadd           // 自增
putstatic   i  // 将修改后的值存入静态变量i
```

而对应 i-- 也是类似

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
isub           // 自减
putstatic   i  // 将修改后的值存入静态变量i
```

而 Java 的内存模型下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![](../../pics/20210913213314.png)

在多线程的情况下会发生指令交错，出现正数、负数、零三种情况

### 临界区 Critical Section

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问共享资源
  - 多个线程读共享资源其实也没有问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
- 一段代码如果存在对共享资源的多线程读写操作，称这段代码为临界区

例如：

```java
static int counter = 0;

static void increment(){
    // 临界区
    counter ++;
}
static void decrement(){
    // 临界区
    counter --;
}
```

### 竞态条件

多个线程在临界区内执行，由于代码的**执行序列**不同而导致**结果无法预测**，称之为发生了竞态条件

## synchronized 解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的

- 阻塞式的解决方案：synchronized, Lock
- 非阻塞式的解决方案：原子变量

下面使用阻塞式的方案： synchronized 来解决上述问题，即俗称**对象锁*，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程再想要获取这个对象锁时就会阻塞。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换

**注意：**

虽然 Java 中的互斥和同步都可以采用 synchronized 关键字来完成，但是它们是有区别的：

- 互斥是保证临界区的竞态条件发生时，同一时刻只能有一个线程执行临界区的代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点
  
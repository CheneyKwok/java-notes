# 共享模型之管程

## 共享变量带来的问题

### Java 体现

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是否为 0？

```java
static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", counter);
    }
```

### 问题分析

以上结果可能是正数、负数、零。因为 Java 中对静态变量的自增，自减并不是原子操作，需从字节码来进行分析

例如对于 i++ 而言 (i 为静态变量)，实际会产生如下的 JVM 字节码指令：

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
iadd           // 自增
putstatic   i  // 将修改后的值存入静态变量i
```

而对应 i-- 也是类似

```java
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
isub           // 自减
putstatic   i  // 将修改后的值存入静态变量i
```

而 Java 的内存模型下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![](../../pics/20210913213314.png)

在多线程的情况下会发生指令交错，出现正数、负数、零三种情况

### 临界区 Critical Section

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问共享资源
  - 多个线程读共享资源其实也没有问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
- 一段代码如果存在对共享资源的多线程读写操作，称这段代码为临界区

例如：

```java
static int counter = 0;

static void increment(){
    // 临界区
    counter ++;
}
static void decrement(){
    // 临界区
    counter --;
}
```

### 竞态条件

多个线程在临界区内执行，由于代码的**执行序列**不同而导致**结果无法预测**，称之为发生了竞态条件

## synchronized 解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的

- 阻塞式的解决方案：synchronized, Lock
- 非阻塞式的解决方案：原子变量

下面使用阻塞式的方案： synchronized 来解决上述问题，即俗称**对象锁*，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程再想要获取这个对象锁时就会阻塞。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换

**注意**

虽然 Java 中的互斥和同步都可以采用 synchronized 关键字来完成，但是它们是有区别的：

- 互斥是保证临界区的竞态条件发生时，同一时刻只能有一个线程执行临界区的代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点
  
### synchronized 

**语法**

```java
synchronized(对象){
    临界区
}
```
**理解**

假如线程1拿到对象锁，当其他线程尝试获取锁时就会阻塞（BLOCKED）,线程1执行完临界区的代码后释放锁同时唤醒其他线程去争取锁

**解决**

```java
 static int counter = 0;
    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
                for (int i = 0; i < 5000; i++) {
                    synchronized (lock){
                        counter++;
                }
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
                for (int i = 0; i < 5000; i++) {
                    synchronized (lock) {
                        counter--;
                }
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", counter);
    }
```

**思考**

synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换打断

- 如果把 synchronized(obj) 放在 for 循环外面，如何理解？
  
  ```java
  synchronized（lock){
      for (int i = 0; i < 5000; i++) {
          counter ++;
      }
  }
  ```
  synchronized 里的整个 for 循环是不可分割的，假如 t1 获得锁，会执行完 5000 次 counter ++ 操作后再释放锁。

- 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？
  
  无法保证对 counter 共享资源操作的原子性，两个线程同时执行临界区代码区获取锁时，获取的不是同一把对象锁，无法保证互斥

- 如果 t1 synchronized(obj) 而 t2 没有加会怎样？
  
  无法保证对 counter 共享资源操作的原子性，由于 t2 没有加锁，当 t1 没有释放锁（未执行完临界区代码）就发生时间片切换时，t2 执行临界区代码不会被阻塞

**总结**

synchronized 用锁保证了临界区代码的原子性，会给临界区的代码加一个锁，当一个线程要执行 synchronized 内的代码（临界区内的代码）时，先要尝试获取这个锁，如果这个锁已经被其他线程获得，那么当前线程就会阻塞（BLOCKED）,等会持有锁的线程释放锁后被唤醒，再去尝试获取锁

**面向对象改进**

```java
class Room {
    private int counter;
    
    public void increment() {
        synchronized (this) {
            counter++;
        }
    }

    public void decrement() {
        synchronized (this) {
            counter--;
        }
    }

    public int getCounter() {
        synchronized (this) {
            return counter;
        }
    }
}

  public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000000; i++) {
                room.increment();
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000000; i++) {
                room.decrement();
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("{}", room.getCounter());
    }
```

## 方法上的 synchronized

```java
class Test{
    public synchronized void test(){

    }
}

等价于

class Test{
    public void test(){
        synchronized(this){

        }
    }
}
```

```java
class Test{
    public synchronized static void test(){

    }
}

等价于

class Test{
    public static void test(){
        synchronized(this){

        }
    }
}
```

### 所谓的“线程八锁”

其实就是考察 synchronized 锁住的是哪个对象

**情况1**

```java
  static class Number{
        public synchronized void a() {
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number number = new Number();
        new Thread(number::a).start();
        new Thread(number::b).start();
    }
```
结果：12 | 21

**情况2**

```java
    static class Number{
        public synchronized void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number number = new Number();
        new Thread(() ->{
            log.info("begin");
            number.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            number.b();
        }).start();
    }
```

结果：1s 2 | 2 1s 1 

**情况3**

```java
    static class Number{
        public synchronized void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }

        public void c() {
            log.info("3");
        }
    }

    public static void main(String[] args) {
        Number number = new Number();
        new Thread(() ->{
            log.info("begin");
            number.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            number.b();
        }).start();
        new Thread(() ->{
            log.info("begin");
            number.c();
        }).start();
    }
```
结果：3 1s 12 | 23 1s 1 | 32 1s 1

**情况4**

```java
  static class Number{
        public synchronized void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number n1 = new Number();
        Number n2 = new Number();
        new Thread(() ->{
            log.info("begin");
            n1.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            n2.b();
        }).start();
    }
```
结果：2 1s 1

**情况5**

```java
static class Number{
        public synchronized static void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number number = new Number();
        new Thread(() ->{
            log.info("begin");
            number.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            number.b();
        }).start();
    }
```
结果：2 1s 1

**情况6**

```java
  static class Number{
        public synchronized static void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized static void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number number = new Number();
        new Thread(() ->{
            log.info("begin");
            number.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            number.b();
        }).start();
    }
```
结果：1s 12 | 2 1s 1

**情况7**

```java
    static class Number{
        public synchronized static void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number n1 = new Number();
        Number n2 = new Number();
        new Thread(() ->{
            log.info("begin");
            n1.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            n2.b();
        }).start();
    }
```
结果：2 1s 1

**情况8**

```java
   static class Number{
        public synchronized static void a() {
            sleep(1);
            log.info("1");
        }
        public synchronized static void b() {
            log.info("2");
        }
    }

    public static void main(String[] args) {
        Number n1 = new Number();
        Number n2 = new Number();
        new Thread(() ->{
            log.info("begin");
            n1.a();
        }).start();
        new Thread(() ->{
            log.info("begin");
            n2.b();
        }).start();
    }
```
结果：1s 12 | 2 1s 1

## 变量的线程安全分析

### 成员变量和静态变量是否线程安全

- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分为两种情况
  - 如果只有读操作，则线程安全
  - 如果有读写，则这段代码是临界区，需要考虑线程安全

### 局部变量是否线程安全

- 局部变量是线程安全的
- 但局部变量引用的对象则未必
  - 如果该对象没有逃离方法的作用范围，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全

### 局部变量线程安全分析

```java
public static void test(){
    int i = 10;
    i++;
}
```
每个线程调用 test() 方法会在每个线程的栈帧中创建多份，因此不存在共享

```java
0: bipush       10
2: istore_0
3: iinc         0, 1
6: return
```
![](../../pics/20210915164359.png)

成员变量举例

```java
public class ThreadUnsafe {
    List<String> list = new ArrayList<>();
    public void method1(int loopNumber) {
        for (int i = 0; i < loopNumber; i++) {
            // 临界区 会产生竟态条件
            method2();
            method3();
        }
    }

    private void method2() {
        list.add("1");
    }

    private void method3() {
        list.remove(0);
    }

    public static void main(String[] args) {
        ThreadUnsafe tu = new ThreadUnsafe();
        for (int i = 0; i < 2; i++) {
            new Thread(() -> tu.method1(200), "Thread" + i).start();
        }
    }
}
```

out:

```java
Exception in thread "Thread0" Exception in thread "Thread1" java.lang.ArrayIndexOutOfBoundsException: -1
	at java.util.ArrayList.remove(ArrayList.java:507)
	at juc.code.ThreadUnsafe.method3(ThreadUnsafe.java:22)
	at juc.code.ThreadUnsafe.method1(ThreadUnsafe.java:13)
	at juc.code.ThreadUnsafe.lambda$main$0(ThreadUnsafe.java:28)
	at java.lang.Thread.run(Thread.java:748)
```

其中一种情况是，如果线程2还未 add，线程1 remove 会报错

分析：

- 无论哪个线程中的menthod2 引用的都是同一个对象的list成员变量
- mehtod3 同理

![](../../pics/20210915194237.png)

将list修改为局部变量可解决上述问题

```java
class ThreadSafe {
    public void method1(int loopNumber) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            // 临界区 会产生竟态条件
            method2();
            method3();
        }
    }

    private void method2() {
        list.add("1");
    }

    private void method3() {
        list.remove(0);
    }
}
```

分析：

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享
- 而 method2 的参数是从 method1 中传递过来，与 method1 引用同一个对象 
- method3同理

![](../../pics/20210915194740.png)

### 方法访问修饰符带来的思考

如果把 method2 和 method3 的方法修改为 public 会不会产生线程安全问题？

- 情况1： 有其他线程调用 method2 和 method3
  
  不会产生线程安全问题。其他线程调用时需要传递其他线程实例 list 的引用，并没有线程共享实例 list
  
- 情况2： 在情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即
  
```java
@Slf4j
public class ThreadSafe {
    public final void method1(int loopNumber) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            // 临界区 会产生竟态条件
            method2(list);
            method3(list);
            log.info("list size:{}", list.size());
        }
    }

    public void method2(List<String> list) {
        list.add("1");
    }

    public void method3(List<String> list) {
        list.remove(0);
    }

    public static void main(String[] args) {
        ThreadSafeSub tu = new ThreadSafeSub();
        for (int i = 0; i < 3; i++) {
            new Thread(() -> tu.method1(200), "Thread" + i).start();
        }
    }
}

class ThreadSafeSub extends ThreadSafe {

    @Override
    public void method3(List<String> list) {
        new Thread(() -> list.remove(0)).start();
    }
} 
```
从这个例子可以看出 private 或 final 提供安全的意义所在，开闭原则中的【闭】

## 常见线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- HashTable
- java.util.concurrent 包下的类

这里的线程安全是指多个线程用它们同一个实例的方法时，是线程安全的。

```java
HashTable table = new HashTable();

new Threa(() -> {
    table.put("key", "value1");
}).start();

new Threa(() -> {
    table.put("key", "value2");
}).start();
```
- 它们的每个方法是原子的
- 但是它们多个方法的组合不是原子的

### 线程安全类方法的组合

分析下面是否线程安全

```java
HashTable table = new HashTable();
// 线程1、线程2

if(table.get("key") == null){
    table.put("key", value);
}
```
不安全，线程1 get 判断为 null 时，还未 put value1 时发生线程切换，线程2 get 判断也为 null，并 put value2，线程1 切换回来后再put value1 将 value2 覆盖

### 不可变类线程安全性

String、Integer 等都是不可类，因为其内部的状态不可变，因此它们的方法都是线程安全的

### 实例分析

- 例1
  
```java
public class MyServlet extends HttpServlet {
    // 是否安全？不安全
    Map<String,Object> map = new HashMap<>();
    // 是否安全？安全
    String S1 = "...";
    // 是否安全？安全
    final String S2 = "...";
    // 是否安全？不安全
    Date D1 = new Date();
    // 是否安全？不安全
    final Date D2 = new Date();
 
 public void doGet(HttpServletRequest request, HttpServletResponse response) {
     // 使用上述变量
 }
}
```
- 例2
  
```java
public class MyServlet extends HttpServlet {
    // 是否安全？不安全
    private UserService userService = new UserServiceImpl();
 
 public void doGet(HttpServletRequest request, HttpServletResponse response) {
    userService.update(...);
 }
}
public class UserServiceImpl implements UserService {
    // 记录调用次数
    private int count = 0;
 
    public void update() {
    // ...
    count++;
    }
}
```

- 例3
  
```java
public class MyServlet extends HttpServlet {
    // 是否安全 安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全 安全
    private UserDao userDao = new UserDaoImpl();

    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    public void update() {
        String sql = "update user set password = ? where username = ?";
        // 是否安全 安全
        try (Connection conn = DriverManager.getConnection("","","")){
            // ...
        } catch (Exception e) {
            // ...
        }
    }
}
```

- 例4
  
```java
public class Test {

    public void bar() {
        // 是否安全
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }

    public foo(SimpleDateFormat sdf);


    public static void main(String[] args) {
        new Test().bar();
    }

```
其中 foo 的行为是不确定的，可能导致不安全的发生，称之为**外星方法**

```java
 public void foo(SimpleDateFormat sdf) {
        String dateStr = "1999-10-11 00:00:00";
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                try {
                    sdf.parse(dateStr);
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
```

- 例5

```java
private static Integer i = 0;

public static void main(String[] args) thro
    List<Thread> list = new ArrayList<>();
    for (int j = 0; j < 2; j++) {
        Thread thread = new Thread(() -> {
            for (int k = 0; k < 5000; k++) 
                synchronized (i) {
                    i++;
                }
            }
        }, "" + j);
        list.add(thread);
    }
    list.stream().forEach(t -> t.start());
    list.stream().forEach(t -> {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    log.debug("{}", i);
}
```

## Monitor 概念

### Java 对象头

以32为虚拟机为例

普通对象

![](../../pics/20210918134747.png)

数组对象

![](../../pics/20210918134818.png)

其中 Mark Word 结构为

![](../../pics/20210918134852.png)

### Monitor(锁)

Monitor 被翻译为监视器或管程

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针

Monitor 结构如下

![](../../pics/20210918142316.png)

- 刚开始 Monitor 中 Owner 为 null
- 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner
- 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 阻塞 (BLOCKED)
- Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时候是非公平的
- WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，在 wait-notify 会分析

**注意**

- synchronized必须是进入同一个对象的 Monitor 才有上述的效果
- 不加 synchronized 的对象不会关联监视器，不遵从以上规则

### synchronized 原理

```java
static final Object lock = new Object();
static int counter = 0;

public static void main(String[] args) {
    synchronized (lock) {
    counter++;
    }
}
```

对应的字节码为

![](../../pics/20210918150806.png)
# 共享模型之内存

共享变量在多线程之间的`可见性`与多条指令执行时的`有序性`问题

## Java 内存模型

 JMM 即 Java Memory Model，它定义了内存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等

 JMM 体现在以下几个方面

- 原子性-保证指令不受线程上下文切换的影响
- 可见性-保证指令不受 CPU 缓存的影响
- 有序性-保证指令不受 CPU 指令并行优化的影响

## 可见性

### 退不出的循环

有这样一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了t 线程无法停止

```java
start boolean run = true;

public start void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while(run){
            // ..
        }
    });
    t.start();
    sleep(1);
    run = false; // 线程 t 不会如预想般停下来
}
```

分析：

- 初始状态， t 线程刚从主内存读取了 run 的值到工作内存

![图 1](../../images/f4fcdd0fbefb033810fb879d0297abf1e4eabbb46853654b16a609e3e12fcb23.png)  

- 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主内存中 run 的访问，提高效率

![图 2](../../images/6a27d50a493664ea9c08ea3591b156d91a07cdee75ea32f9895415a2a9843b44.png)  

- 1 秒之后，main 线程修改了 run 的值，并同步至主内存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![图 3](../../images/0b94164e54b0a08bb1d6bdf7bea7a7e6734e91a2fd0599e3504983eb7ad9b69f.png)  

### 解決方法

volatile (易变关键字)，可以用来修饰成员变量和静态成员变量，避免线程从自己的工作缓存中查找变量的值，必须到主内存中获取它的值，线程操作 volatile 变量都是直接操作主内存

### 可见性 VS 原子性

前面例子体现的实际是可见性，它保证的是多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。上例从字节码理解是这样的

```java
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false
```

比较一下之前线程安全举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错

```java
// 假设i的初始值为0 
getstatic i // 线程2-获取静态变量i的值 线程内i=0 
getstatic i // 线程1-获取静态变量i的值 线程内i=0 
iconst_1 // 线程1-准备常量1 
iadd // 线程1-自增 线程内i=1 
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 
iconst_1 // 线程2-准备常量1 
isub // 线程2-自减 线程内i=-1 
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
```

**注意：**

synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是 synchronized 是属于重量级操作，性能相对更低

加 System.out.println() 打印也可以保证正确看到 run 的修改，因为其底层 加了 synchronized 关键字

```java
private void newLine() {
        try {
            synchronized (this) {
                ensureOpen();
                textOut.newLine();
                textOut.flushBuffer();
                charOut.flushBuffer();
                if (autoFlush)
                    out.flush();
            }
        }
        catch (InterruptedIOException x) {
            Thread.currentThread().interrupt();
        }
        catch (IOException x) {
            trouble = true;
        }
    }
```
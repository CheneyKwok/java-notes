# 共享模型之内存

共享变量在多线程之间的`可见性`与多条指令执行时的`有序性`问题

## Java 内存模型

 JMM 即 Java Memory Model，它定义了内存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等

 JMM 体现在以下几个方面

- 原子性-保证指令不受线程上下文切换的影响
- 可见性-保证指令不受 CPU 缓存的影响
- 有序性-保证指令不受 CPU 指令并行优化的影响

## 可见性

### 退不出的循环

有这样一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了t 线程无法停止

```java
start boolean run = true;

public start void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while(run){
            // ..
        }
    });
    t.start();
    sleep(1);
    run = false; // 线程 t 不会如预想般停下来
}
```

分析：

- 初始状态， t 线程刚从主内存读取了 run 的值到工作内存

![图 1](../../images/f4fcdd0fbefb033810fb879d0297abf1e4eabbb46853654b16a609e3e12fcb23.png)  

- 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主内存中 run 的访问，提高效率

![图 2](../../images/6a27d50a493664ea9c08ea3591b156d91a07cdee75ea32f9895415a2a9843b44.png)  

- 1 秒之后，main 线程修改了 run 的值，并同步至主内存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![图 3](../../images/0b94164e54b0a08bb1d6bdf7bea7a7e6734e91a2fd0599e3504983eb7ad9b69f.png)  

### 解決方法

volatile (易变关键字)，可以用来修饰成员变量和静态成员变量，避免线程从自己的工作缓存中查找变量的值，必须到主内存中获取它的值，线程操作 volatile 变量都是直接操作主内存

### 可见性 VS 原子性

前面例子体现的实际是可见性，它保证的是多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。上例从字节码理解是这样的

```java
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false
```

比较一下之前线程安全举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错

```java
// 假设i的初始值为0 
getstatic i // 线程2-获取静态变量i的值 线程内i=0 
getstatic i // 线程1-获取静态变量i的值 线程内i=0 
iconst_1 // 线程1-准备常量1 
iadd // 线程1-自增 线程内i=1 
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 
iconst_1 // 线程2-准备常量1 
isub // 线程2-自减 线程内i=-1 
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
```

**注意：**

synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是 synchronized 是属于重量级操作，性能相对更低

加 System.out.println() 打印也可以保证正确看到 run 的修改，因为其底层 加了 synchronized 关键字

```java
private void newLine() {
        try {
            synchronized (this) {
                ensureOpen();
                textOut.newLine();
                textOut.flushBuffer();
                charOut.flushBuffer();
                if (autoFlush)
                    out.flush();
            }
        }
        catch (InterruptedIOException x) {
            Thread.currentThread().interrupt();
        }
        catch (IOException x) {
            trouble = true;
        }
    }
```

### volatile 改进两阶段终止模式

```java
public class TwoPhaseTerminationDemo2 {

    public static void main(String[] args) throws InterruptedException {

        TwoPhaseTermination2 tpt = new TwoPhaseTermination2();
        tpt.start();
        TimeUnit.SECONDS.sleep(10);
        log.info("停止监控");
        tpt.stop();
    }
}

@Slf4j
class TwoPhaseTermination2 {

    private Thread monitor;

    private volatile boolean stop;

    // 启动监控线程
    public void start() {
        monitor = new Thread(() ->{
            while (true){
                if(stop){
                    log.info("料理后事");
                    break;
                }
                try {
                    TimeUnit.SECONDS.sleep(2);
                    log.info("执行监控");
                } catch (InterruptedException e) {
                }
            }
        });
        monitor.start();
    }

    // 停止监控线程
    public void stop() {
        stop = true;
        monitor.interrupt();
    }
}
```

### 同步模式之 Balking

1、定义

Balking(犹豫)模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需做了，直接结束返回

2、实现

例如：

```java
public class MonitorService {
    // 用来表示是否已经有线程在执行启动了
    private volatile boolean starting;

    public void start(){
        log.info("尝试启动监控线程...");
        synchronized (this) {
            if(starting){
                return;
            }
            starting = true;
        }
        // 真正启动监控线程..
    }
}
```

实现线程安全的单利

```java
public final class Singleton {
    public Singleton() {}

    private static Singleton INSTANCE = null;


    public static synchronized Singleton getInstance () {
        if(INSTANCE != null) {
            return INSTANCE;
        }
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```

对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待

## 有序性

JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，例如

```java
static int i;
static int j;
// 在某个线程内执行如下赋值操作
i = ...;
j = ...;
```

上面代码真正执行时，既可以是

```java
i = ...;
j = ...;
```

也可以是

```java
j = ...;
i = ...;
```

这种特性称之为指令重排，多线程下的指令重排会影响正确性。

## volatile 原理

volatile 的底层实现原理是内存屏障，Memory Barrier

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

### 如何保证可见性

- 写屏障( sfence ) 保证在该屏障之前的，对共享变量的改动，都同步到主内存中

```java
public void actor2(I_Result r){
    num = 2;
    ready = true; // ready 是 volatile 赋值，带写屏障
    // 写屏障
}
```

- 而读屏障( lfence ) 保证在该屏障之后，对共享变量的读取，加载的是内存中的最新的数据

```java
public void actor1(I_Result r){
    // 读屏障
    // ready 是 volatile 读取 带读屏障
    if(ready) {
        r.r1 = num + num;
    }else{
        r.r1 = 1;
    }
}
```

![图 1](../../images/ecc8c1ba461f69b02b0deb8711d4f0d53ce14af86b864cec273d9b082b20111e.png)  

### 如何保证有序性

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后

```java
public void actor2(I_Result) {
    num = 2;
    ready = true; // ready 是 volatile 赋值，带写屏障
    // 写屏障
}
```

- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

```java
public void actor1(I_Result r){
    // 读屏障
    // ready 是 volatile 读取 带读屏障
    if(ready) {
        r.r1 = num + num;
    }else{
        r.r1 = 1;
    }
}
```

总结: 不能解决指令交错

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去
- 而有序性的保证也只是保证了本线程内的相关代码不被重排序

![图 2](../../images/feb218d641e13721cf4dc7b338de10464da0e588d27b488173fed5ad778575f5.png)  

# 共享模型之内存

共享变量在多线程之间的`可见性`与多条指令执行时的`有序性`问题

## Java 内存模型

 JMM 即 Java Memory Model，它定义了内存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等

 JMM 体现在以下几个方面

- 原子性-保证指令不受线程上下文切换的影响
- 可见性-保证指令不受 CPU 缓存的影响
- 有序性-保证指令不受 CPU 指令并行优化的影响

## 可见性

### 退不出的循环

有这样一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了t 线程无法停止

```java
start boolean run = true;

public start void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while(run){
            // ..
        }
    });
    t.start();
    sleep(1);
    run = false; // 线程 t 不会如预想般停下来
}
```

分析：

- 初始状态， t 线程刚从主内存读取了 run 的值到工作内存

![图 1](../../images/f4fcdd0fbefb033810fb879d0297abf1e4eabbb46853654b16a609e3e12fcb23.png)  

- 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主内存中 run 的访问，提高效率
- 1 秒之后，main 线程修改了 run 的值，并同步至主内存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

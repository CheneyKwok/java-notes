# Redis

## redis 单线程为什么这么快

- **为什么采用单线程**
  
  因为 redis 主线程是基于内存操作，在处理多条命令时，如果使用多线程，可能执行一条命令只要 2ms，但 cpu 给执行这个命令的线程只分配了 1ms 的时间片，此时会切换到另一线程，下一次再切换回来，但是基于内存操作本就是很快的，并不需要阻塞当前线程去执行其他任务，来回的切换上下文的时间反而可能消耗更长的时间，从而影响了性能。

- **IO 多路复用**
  
  redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler。它是单线程，所以 redis 才叫做单线程的模型， redis也有后台线程。它采用 IO 多路复用机制来同时监听多个 Socket，根据 Socket 上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 redis 内部的线程模型额简单性。

  文件事件处理器的结构包含 4 个部分：

  - 多个 Socket
  - IO 多路复用程序
  - 文件事件派发器
  - 事件处理器( 命令请求处理器、命令回复处理器、连接应答处理器)
  
  多个 Socket 可能并发的产生不同的事件，IO 多路复用程序会监听多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中有序、同步取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。然后一个 Socket 的事件处理完之后，IO 多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。

  1. redis 启动初始化时，将连接应答处理器跟 AE_READABLE 事件关联
  2. 若一个客户端发生连接，将会产生一个 AE_READABLE 事件，然后由连接应答处理器负责和客户端建立连接，创建客户端对应的 Socket，同时将这个 Socket 的 AE_READABLE 事件和命令请求处理器关联，使得客户端可以向主服务器发送命令请求
  3. 当客户端向 redis 发请求时 (无论读还是写)， 客户端 Socket 都会产生一个 AE_READABLE 事件，触发命令请求处理器，处理器读取客户端的命令内容，然后传给相关程序执行
  4. 当 redis 服务器准备好给客户端的响应数据后，会将 Socket 的 AE_WRITABLE 事件和命令回复处理器关联，当客户端准备好读取响应数据时，会在 Socket 产生一个 AE_WRITABLE 事件，由对应命令回复处理器处理，即将准备好的响应数据写入 Socket，供客户端读取
  5. 命令回复处理器全部写完到 Socket 后，就会删除该 Socket 的 AE_WRITABLE 事件和命令回复处理器的映射

- **总结**

  单线程快的原因：

  - 纯内存操作
  - 核心是基于非阻塞的 IO 多路复用机制
  - 单线程反而避免了多线程的频繁上下文切换带来的性能问题

# 垃圾回收

## 如何判断对象可以回收

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就 + 1，当引用失效时，计数器 -1 。任何时刻计数器为 0 的对象就是不再被使用的。

但是引用计数法无法解决对象之间相互循环引用问题，所以，JVM 没有采用引用计数法来管理内存

### 可达性分析算法

通过一系列称为 `GC Roots` 的对象为起始点，从这些节点开始向下搜索，搜索走过的路径就被称为`引用链`，当一个对象到 `GC Roots` 之间没有任何引用链时，则证明此对象不再被使用

![图 4](../../.image/866cd1e6ef215962b95efcd31a72cd7080e33d6a4dc160434d3481307a352ab8.png)  

并不是所有对象都可以作为 `GC Roots` 对象，只有下列对象可以作为 `GC Roots` 的对象:

- 虚拟机(栈帧中的本地变量表)中引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈 JNI (即一般说的 Native 方法) 引用的对象

### 四种引用

- 强引用 (不回收)：类似 Object obj = new Object(); 这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

- 软引用 (内存不足即回收)：用来描述一些还有用但并非必需的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收哦。如果这次回收还没有足够的内存，才会抛出内存溢出的异常，JDK 提供 SoftReference 类来实现软引用。

- 弱引用 (发现即回收)：也是用来描述一些还有用但并非必需的对象，但是它的强度比软引用更弱一些，被引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK 提供 WeakReference 类来实现弱引用。

- 虚引用 (对象回收跟踪)：它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收之前收到一个系统通知。JDK 提供 PhantomReference 类来实现虚引用。

- 终结器引用：用以实现对象的 finalize() 方法，其内部配合引用队列使用，在 GC 时，终结器引用入队，由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize() 方法，第二次 GC 时才能回收被引用对象。

### 垃圾回收算法

#### 标记 - 清除算法

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。

缺点：

- 第一个是执行效率不稳定，如果 Java 堆中包含大量对象，而其中大部分是需要回收的，这时就必须要进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象的增长而降低
- 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

#### 标记 - 复制算法

将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还活着的内存复制到另外一块上面，然后再把已使用过内存空间一次清理掉

优点：

- 如果内存中多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的情况

缺点：

- 将可用内存缩小为了原来的一半，空间浪费太多

后 IBM 公司对新生代 “朝生夕灭” 的特点做了更量化的全市--新生代的对象有 98% 熬不过第一轮收集。因此并不需要按照 1:1 的比例来划分内存空间

根据这种 “朝生夕灭” 的特点，有了一种更优化的半区复制分代策略，称为 `Appel` 回收：

```java
把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中的一块 Survivor。当发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次复制到另外一快 Survivor 空间上，然后直接清理掉 Eden 和 已使用过的 Survivor。HotSpot 虚拟机默认 Eden 和 Survivor 的比例是 8:1
```

不过任何人都无法保证每次回收都只有不多于一块 Survivor 空间大小的对象存活，因此 `Appel` 回收还有一个罕见的 “逃生门” 的安全设计：当 Survivor 空间不足以容纳一次 Minor GC 之后，就需要依赖其他内存区域（大多是是老年代）进行分配担保，即通过分配担保机制直接进入老年代

#### 标记 - 整理算法

让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存

缺点：

- 如果移动存活对象，就需要更新所有引用这些对象的地方

#### 相关 VM 参数

|  含义  |  参数  |
| :---:  |:----: |
| 堆初始大小 | -Xms |
| 堆最大大小 | -Xmx 或 -XX:MaxHeapSize=size |
| 新生代大小 | -Xmn 或 -XX:MaxNewSize=size |
| 幸存区比例（动态） | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy|
| 幸存区比例 | -XX:SurvivorRatio=ratio |
| 晋升阈值 | -XX:MaxTenuringThreshold=threshold |
| 晋升详情 | -XX:+PrintTenuringDistribution |
| GC 详情 | -XX:+PrintGCDetails -verbose:gc |
| FullGC 前 Ninor GC | -XX:+ScavengeBeforeFullGC |
